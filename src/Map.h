#pragma once
#define MAP_H

#include "stdafx.h"
#include "Player.h"
#include <vector>

class Player;
class Map;

using namespace std;

//link between two regions, aka edge
struct mapLink
{
	//the linked regions
	size_t region1, region2;

	//constructor
	mapLink(size_t r1, size_t r2) : region1(r1), region2(r2) {}
};

//region, aka vertex
struct region
{
	//land types
	const int HILL = 1;
	const int MOUNTAIN = 2;
	const int FARMLAND = 3;
	const int FOREST = 4;
	const int SWAMP = 5;
	const int WATER = 6;


	//name of the region
	std::string name;
	//region type
	int type;

	//owner of the region
	Player *owner = nullptr;
	//number of tokens
	int tokens;

	//default constructor
	region() : owner(nullptr) {};

	//parameters that are generated by the map
	bool edge;
	
	bool magic;

	bool cavern;

	bool mine;


	//parameters that are generated in game
	bool hole = false;

	bool lair = false;

	bool encampment = false;

	bool fortress = false;

	bool decline = false;

	//contructors
	region(string n) : name(n),  tokens(0), owner(nullptr) {}
	region(string n, bool m, bool l) : name(n), owner(nullptr)
	{
		if (l) {
			tokens = 1;
			decline = true;
		}
		else
			tokens = 0;
	}

	//constructor with most params
	region(string n, int ty, bool tri, bool co, bool ma, bool ca, bool mi) : name(n), type(ty), edge(co), magic(ma), cavern(ca), mine(mi) {
		if (tri) {
			tokens = 1;
			decline = true;
		}
		else
			tokens = 0;
		
	}

	//simple way to represent a region as a string
	std::string toString() {
		string ret = name;

		switch (type)
		{
		case (1):
			ret = "Hill " + ret;
			break;
		case (2):
			ret = "Mountain " + ret;
			break;
		case (3):
			ret = "Farmland " + ret;
			break;
		case (4):
			ret = "Forest " + ret;
			break;
		case (5):
			ret = "Swamp " + ret;
			break;
		case (6):
			ret = "Water " + ret;
			break;
		}

		if (magic)
			ret = "Magic " + ret;

		if (edge)
			ret += " at the edge";

		if (cavern || hole || lair || encampment || fortress || mine) {
			ret += " with a ";
			bool and = false;
			if (hole) {
				ret += "Hole-In-The-Ground ";
				and = true;
			}
			if (lair) {
				if (and)
					ret += "and a ";
				ret += "Lair ";
				and = true;
			}
			if (encampment) {
				if (and)
					ret += "and an ";
				ret += "Encampment ";
				and = true;
			}
			if (fortress) {
				if (and)
					ret += "and a ";
				ret += "Fortress ";
				and = true;
			}
			if (cavern) {
				if (and)
					ret += "and a ";
				ret += "Cavern ";
				and = true;
			}
			if (mine) {
				if (and)
					ret += "and a ";
				ret += "Mine ";
				and = true;
			}

		}
		return ret;
	}
};

class Map {
private:
	//used to see if map is a connected graph
	void recursiveDepthFirstTraversal(std::vector<size_t> &, std::vector<bool> &, size_t);
public:


	//vector of all the regions
	std::vector<region> regions;
	//vector of all the links
	std::vector<mapLink> links;

	//constructor
	Map(const size_t, const size_t);

	//simply adds a new region of the chosen name
	void addRegion(string);


	//simply adds a new region of the chosen name
	void addRegion(string, char type);

	void addRegion(string, char type, bool tribal, bool coastal, bool magic, bool cavern, bool mine);

	//adds a new link between 2 regions
	void addLink(const size_t, const size_t);

	//Returns vector with results of recursiveDepthFirstTraversal
	std::vector<size_t> dft(const size_t);

	// Checks if all regions are linked
	bool linked();

	bool empty();

	void decline(Player*);

	string toString();

	friend ostream &operator<<(ostream &output, Map &m) {
		output << m.toString();
		return output;
	}
};